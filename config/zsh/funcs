# shellcheck disable=SC2148
# Do not warn for "unknown shell" since this file will be included from zshrc

# find absolute path for given executable in PATH.
# omits shell builtins, shell functions and shell aliases while searching.
function find_exec_in_path {
	# $1 is executable name
	# shellcheck disable=SC2230  # using `command -v` here makes things more diffucult
	which -a "$1" | grep -e "^/" | head -1
}

# check if given argument is numeric or not
function is_numeric {
	case "${1#[+-]}" in
		(*[!0123456789]*)
			return 1
			;;
		('')
			return 1
			;;
		(*)
			return 0
			;;
	esac
}

# wrapper for ed(1) to change ed's prompt.
function ed {
	local __exec
	# shellcheck disable=SC2154 # $ED_PROMPT should be defined in zsh_env
	local __prompt="${ED_PROMPT}"

	__exec=$(find_exec_in_path "ed")
	if [ -z "${__exec}" ]; then
		echo "ed not found in PATH";
		return 255;
	fi
	if [ -z "${__prompt}" ]; then
		__prompt="ed> "
	fi
	eval "${__exec}" "-p" "\"${__prompt}\"" "$@"
}

# wraps `lp` to hide common parameters
# `$PRINTER` must contain name of printer to use while printing.
# also accepts any parameter accepted by `lp`
function print_file {
	local __exec

	__exec=$(find_exec_in_path "lp")
	if [ -z "${__exec}" ]; then
		echo 'cound not found "lp" on system. you should install it.'
		return 254;
	fi

	# shellcheck disable=SC2154 # $PRINTER should be defined in zsh_env
	if [ -z "${PRINTER}" ]; then
		# shellcheck disable=SC2016  # we want to print variable name
		echo 'variable $PRINTER is not set';
		return 254;
	fi

	eval "${__exec}" -d "${PRINTER}" "$@"
}

function tex_to_pdf {
	pdflatex "$1"
}

# convert given markdown file into a pdf document
function md_to_pdf {
	pandoc --pdf-engine=pdflatex -V geometry:"top=2cm, bottom=1.5cm, left=2.cm, right=2cm" -o "$1.pdf" "$1"
}

# make a new directory and cd into it
function mkcd {
	mkdir -p "$1" && cd "$1" || return 255
}

# rm files in cwd and all sub-directoriesolder than given number of days
function rmolder {
	local __num_days

	if [ -z "$(command -v find)" ]; then
		echo 'find not found';
		return 255;
	fi

	__num_days="$1"
	if [ -z "${__num_days}" ]; then
		__num_days="7"
	fi

	case "${__num_days}" in
		''|*[!0-9]*) echo 'given number of days is not nuemric'; return 254 ;;
		*) ;;
	esac

	# do a dry run, and print files if tehre is more than 1 parameter
	if [ -z "$2" ]; then
		find . -type f -mtime +"${__num_days}" -print -delete
	else
		find . -type f -mtime +"${__num_days}"
	fi
}

# rm all empty sub-direcctories in cwd.
function rmempty {
	if [ -z "$(command -v find)" ]; then
		echo 'find not found';
		return 255;
	fi

	find . -type d -empty -print -delete
}

# create a new markdown note with name "$NAME_$DATE.md"
function mdnote {
	if [ "$#" != "1" ]; then
		return 255;
	fi
	# shellcheck disable=SC2154 # $EDITOR should be defined in zsh_env
	${EDITOR} "$1_$(date +%F).md"
}

# archive given directory in a tar archive
function ftar {
	tar cvf "$1.tar" "$1"
}

# archive given directory in a tar.gz archive
function ftargz {
	tar cvzf "$1.tar.gz" "$1"
}

# search recursively for files with given extension in given directory and
# add them into a tar.gz archive
function ftargz_ext {
	local PATTERN="$1"
	local DIR="$2"
	local OUTP

	if [ -z "${DIR}" ]; then
		DIR="."
	fi

	OUTP="$(basename "$(readlink -f "${DIR}")").tar.gz"

	find "${DIR}" -name "${PATTERN}" -exec tar cvzf "${OUTP}" {} +
}

# unzip list of zip files into seperate directories
function unzipdir {
	if [ -z "$(command -v unzip)" ]; then
		echo "unzip not found";
		return 255;
	fi

	for file in "$@"; do
		local ext="${file##*.}"
		local base
		base="$(basename "${file}" ".${ext}")"
		if file "${file}" 2>/dev/null | grep -vq 'Zip archive data'; then
			echo "ERROR: not a valid zip file, skipping: ${file}";
			continue;
		fi

		unzip "${file}" -d "${base}"
	done
}

# designed to wrapped by another shell function, do not use directly
# $1 = file name pattern to search
# $2 = string to grep in command output
# $3 command to run for each file
# $@:4 arguments for given command
function __grep_generic {
        for f in ${~1}; do
		echo "===== FILE: \"${f}\" =====";
		"${3}" "${@:4}" "${f}" | grep "${2}";
	done
	echo "==== DONE ====";
}

function grep_libdep {
	__grep_generic "$1" "$2" "readelf" "-a"
}

function grep_symbols {
	__grep_generic "$1" "$2" "nm" "-a" "-l" "-C"
}

function sizeof {
	local __dir
	local __root

	__dir=$(readlink -f "$1")
	__root=$(pwd)

	cd "${__dir}" || return 255
	du -csh ./*
	cd "${__root}" || return 255
}

# use `watch` and `grep` to monitor Dirty and Writeback bytes in /proc/meminfo
function sync_progress {
	local __period

	__period="$1"

	if [ -z "${__period}" ]; then
		__period="0.5"
	fi

	watch -n "${__period}" -d grep -e Dirty: -e Writeback: /proc/meminfo
}

# revert git repository into fresh state.
# * removes all out of tree files
# * reset git repo to HEAD
# * resets all submodules into their respective HEAD's
# * update all submodules
function repo_rinse {
	git clean -xfd
	git submodule foreach --recursive git clean -xfd
	git reset --hard
	git submodule foreach --recursive git reset --hard
	git submodule update --init --recursive
}

# run given command until it fails the print it stdout and stderr outputs of
# its failure followed by number of runs it takes until command fails.
function run_until_fails {
	local CMD="$*"
	local COUNTER=0

	local SOUT
	local SERR

	SOUT=$(mktemp)
	SERR=$(mktemp)

	while "${CMD}" >"${SOUT}" 2>"${SERR}"; do
		COUNTER=$((COUNTER + 1))
	done

	cat "${SOUT}"
	cat "${SERR}"

	echo "[INF] ${CMD} failed after ${COUNTER} attempts."

	rm -f "${SOUT}" "${SERR}"
}

function gif_to_mp4 {
	if [ -z "$(command -v ffmpeg)" ]; then
		echo "ffmpeg not found!";
		return 255;
	fi
	local inp="$1";
	local out="${inp%.*}.mp4"
	echo "${out}"
	ffmpeg -i "${inp}" -movflags faststart -pix_fmt yuv420p -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2" "${out}"
}

# ffmpeg_undefault_ytdl_subtitle - unset default flag for 1st subtitle stream in
# video file
#
#`youtube-dl` (or its fork `yt-dlp`) sets 1st subtitle stream as "default" when
# embedding subtitle(s) into downloaded video file(s). This functions loops over
# all the video files with extensions `.mkv`, `.mp4`, and `.webm`, and unsets
# `default` flag for 1st subtitle stream
function ffmpeg_undefault_ytdl_subtitle {
	local indir
	local outdir
	local outfile

	if [ -z "$(command -v ffmpeg)" ]; then
		echo "ffmpeg not found!"
		return 255
	fi

	indir="${1}"
	outdir="${1}-nodefault"

	if ! [ -d "${indir}" ]; then
		echo "Directory ${indir} not exists"
		return 254
	fi

	if ! [ -d "${outdir}" ]; then
		echo "Creating output directory ${outdir}"
		mkdir -p "${outdir}"
	fi

	setopt +o nomatch

	for infile in "${indir}/"*.{mkv,mp4,webm}; do
		outfile="${outdir}/$(basename "${infile}")"

		echo "Processing ${infile} --> ${outfile}"

		ffmpeg -i "${infile}" -c copy -map 0 -disposition:s:0 -default "${outfile}"
	done

	setopt -o nomatch
}

# ffmpeg_sub_embed - embed given subtitles into given media file
#
# Usage:
#   ffmpeg_sub_embed FILE SUBTITLE_DIR [SUBTITLE_EXT] [OUTPUT_EXTENSION]
#
# Notes:
#   * This function expects both media and subtitle file with name file names,
#   and different extensions
#
#   * This function depends on `ffmpeg_subtitle_embed script from dotfiles/sbin.
function ffmpeg_sub_embed {
	local sub_dir
	local sub_ext
	local out_ext
	local inp
	local out

	inp="$1"
	sub_dir="$2"
	sub_ext="$3"
	out_ext="$4"

	if ! [ -f "${inp}" ]; then
		echo "File ${inp} does not exits"
		return 255
	fi

	if [ -z "${sub_dir}" ]; then
		sub_dir="Subs"
	fi

	if [ -z "${sub_ext}" ]; then
		sub_ext="srt"
	fi

	sub="${sub_dir}/${inp%.*}.${sub_ext}"

	if [ -z "${out_ext}" ]; then
		out_ext="${inp##*.}"
	fi

	out="$(echo "${inp}" | grep -Eo '^.*S[0-9]+E[0-9]+' | tr '.' ' ').${out_ext}"

	echo "${inp} + ${sub} -> ${out}"

	ffmpeg_subtitle_embed --input "${inp}" --sub eng English "${sub}" --output "${out}" --run
}

# ffmpeg_to_x265 - Convert video stream to x265 while keeping all the other streams
#
# This function used to re-encode video stream to x265 without touching any other
# stream(s) or metadata in given list of files.
#
# This functions depends on VAAPI hardware acceleration, and hevc_vaapi from ffmpeg
#
# Usage:
#   ffmpeg_to_x265 [-d vaapi_device] [-p x265_preset] [-q quality] [-f find_pattern] [-r replace_pattern] [-h] FILE_LIST
#   options:
#       -d vaapi_device (default=/dev/dri/renderD128)
#       -f string: pattern to search in file names )default=x264)
#       -h: show this help
#       -p [ultrafast|superfast|veryfast|faster|fast|medium|slow|slower|veryslow|placebo]: x265 preset to use (default=slower)
#       -q level: quality level (default=25, smaller number = better quaity)
#       -r string: repalcement for patterns found in file names (default=x265)
function ffmpeg_to_x265 {
	local inp
	local outp
	local name
	local ext
	local find
	local replace
	local vaapi_dev
	local preset
	local quality
	local OPTIND
	local opt
	local ret

	find='x264'
	replace='x265'
	vaapi_dev='/dev/dri/renderD128'
	preset="slower"
	quality='25'

	if [ -z "$(command -v ffmpeg)" ]; then
		echo "ffmpeg not found in PATH"
		return 255
	fi

	if ! ffmpeg -hide_banner -encoders | grep -q hevc_vaapi; then
		echo "looks like ffmpeg does not support 'hevc_vaapi' encoder"
		return 254
	fi

	while getopts ":d:f:h:p:q:r:" opt; do
		case "${opt}" in
			d)
				vaapi_dev="${OPTARG}"
				;;
			f)
				find="${OPTARG}"
				;;
			p)
				preset="${OPTARG}"
				;;
			q)
				quality="${OPTARG}"
				;;
			r)
				replace="${OPTARG}"
				;;
			h)
				;&
			*)
				cat <<- 'HELP'
ffmpeg_to_x265 [-d vaapi_device] [-p x265_preset] [-q quality] [-f find_pattern] [-r replace_pattern] [-h] FILE_LIST
options:
    -d vaapi_device: hardware device to use for encoding (default=/dev/dri/renderD128)
    -f string: pattern to search in file names (default=x264)
    -h: show this help
    -p [ultrafast|superfast|veryfast|faster|fast|medium|slow|slower|veryslow|placebo]: x265 preset to use (default=slower)
    -q level: quality level (default=25, range=0-51, smaller=better)
    -r string: repalcement for patterns found in file names (default=x265)
HELP
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))

	for f in "${@}"; do
		inp="$(basename "${f}")"
		name="${inp%.*}"
		ext="${inp##*.}"

		if [ -n "${find}" ]; then
			name="${name//${find}/${replace}}"
		fi

		if [ "${ext}" != 'mkv' ]; then
			ext='mkv'
		fi

		outp="${name}.${ext}"

		ffmpeg					\
			-threads "$(nproc)"		\
			-hwaccel vaapi			\
			-vaapi_device "${vaapi_dev}"	\
			-i "${f}"			\
			-vf 'format=nv12,hwupload'	\
			-aud true			\
			-map 0				\
			-c:a copy			\
			-c:s copy			\
			-c:v hevc_vaapi			\
			-rc_mode CQP			\
			-global_quality "${quality}"	\
			-profile:v main			\
			-preset "${preset}"		\
			-f 'matroska'			\
			"${outp}"

		ret="${?}"
		if [ "${ret}" -ne '0' ]; then
			return "${ret}"
		fi
	done
}

# heic_to_x - convert given heic image (hevc encoding) to desired format
#
# This functions depends on `magick` command from imagemagick
# see `heic_to_x -h` for usage
function heic_to_x {
	local _ans
	local format
	local input
	local monitor
	local output
	local quality

	_ans=''
	format=''
	input=''
	monitor='false'
	output=''
	quality='100'

	if [ -z "$(command -v magick)" ]; then
		echo 'magick (imagemagick) not found in PATH'
		return 255
	fi

	while getopts ':f:h:i:mo:q:' opt; do
		case "${opt}" in
			f)
				format="${OPTARG}"
				;;
			i)
				input="${OPTARG}"
				;;
			m)
				monitor='true'
				;;
			q)
				quality="${OPTARG}"
				;;
			h)
				;&
			*)
				cat <<- 'HELP'
heic_to_x -f format -i file [-q quality]
options:
    -f format: format/extension for output file
    -i file: input file in `heic` format
    -h: show this help
    -m: show perogress bar of operation
    -q quality: quality level of output, in percentage (default 100)
HELP
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))

	if [ -z "${input}" ]; then
		echo "Missing input file"
		return 254
	fi

	if [ -z "${format}" ]; then
		echo "Missing output format"
		return 253
	fi

	if ! is_numeric "${quality}"; then
		echo "Quality value is not numeric"
		return 252
	fi

	if [ "${quality}" -gt '100' ] || [ "${quality}" -lt '0' ]; then
		echo "Quality is not between [0-100]"
		return 251
	fi

	output="${input%.*}.${format}"

	# because `magick` does not check if output file is already exists
	if [ -e "${output}" ]; then
		echo "File ${output} already exists, overwrite?"
		select _ans in 'Yes' 'No'; do
			case "${_ans}" in
				Yes)
					break
					;;
				No)
					return 2
					;;
			esac
		done
	fi

	if [ 'true' = "${monitor}" ]; then
		magick '-monitor' "${input}" '-quality' "${quality}" "${output}"
	else
		magick "${input}" '-quality' "${quality}" "${output}"
	fi
}

## extra helpers for using heic_to_x
# heic_to_jpg - convert heic iamges to jpg
function heic_to_jpg {
	heic_to_x -f 'jpg' "${@}"
}

# heic_to_png - convert heic images to png
function heic_to_png {
	heic_to_x -f 'png' "${@}"
}
## end of extra helpers for heic_to_x

#
# lsifr - list installed packages from given pacman repo
#
# Usage:
#   lsfr $reponame
#
# Notes:
#   * Unlike `paclist` from `community/pacman-contrib` package, also shows
#   insatalled version of pacakge and lastest version available on given repo.
#
#   * If installed version string does not match with repo version string,
#   installed package might be installed from another repo.
#
function lsifr {
	if [ -z "$(command -v pacman)" ]; then
		echo "pacman not found on system, can't continue!";
		return 255;
	fi

	pacman -Sl "$1" | grep 'installed' | cut -d' ' -f2-
}

## aurutils helpers

function aur-remove {
	# remove given list of packages from local AUR database
	# depends on `repo-remove` from `pacman` package
	# depends on `aurutils` package from AUR.
	# Only works on the first repo reported by `aur repo --list-path`
	# arguments:
	# "$@" -> package names to remove
	local __db_path

	if [ -z "$(find_exec_in_path "aur")" ] ; then
		echo "aur not found in PATH";
		return 255;
	fi

	__db_path="$(aur repo --list-path 2>/dev/null | head -n 1)"
	if [ -z "${__db_path}" ] ; then
		echo "error: ${__db_path} is empty";
		return 255;
	fi

	repo-remove "${__db_path}" "$@"
	for f in "$@"; do
		echo "deleting files of package: ${f}"
		find "${__db_path}" -name "${f}*" -print -delete
	done

	# shellcheck disable=SC2016  # we don't want to expand variables here
	echo 'you may want to run `sudo pacman -Sc` to cleanup more space.'
}

# Used to checkk diffs between $FILE and $FILE.orig before commiting current
# version of $FILE
# Only supports `neovim`'s diff mode.
function svn-diff-orig {
	local __ans

	for f in $(svn status | grep '\.orig$' | awk '{print $2}'); do
		nvim -d "${f%.orig}" "${f}";
		printf '%s' "Erase '${f}'? "
		select __ans in "Yes" "No" "Exit"; do
			# shellcheck disable=SC2249 # input sanitized by `select`
			case "${__ans}" in
				Yes)
					rm "${f}"
					continue 2;;
				No)
					continue 2;;
				Exit)
					break 2;;
			esac
		done
	done
}

# wrap `telnet` with `tee` to always log telnet console to file
# log file name format: telnet_YYYY-mm-DD_HH:MM:SS.log
function telnet_log {
	local __date
	local __tee
	local __telnet

	__date="$(command -vp date)"
	__tee="$(command -vp tee)"
	__telnet="$(command -vp telnet)"

	if [ -z "${__date}" ]; then
		printf '%s\n' 'date not found'
		return 255;
	fi

	if [ -z "${__tee}" ]; then
		printf '%s\n' 'tee not found'
		return 254
	fi

	if [ -z "${__telnet}" ]; then
		printf '%s\n' 'telnet not found'
		return 253
	fi

	"${__telnet}" "$@" | "${__tee}" -i telnet_"$("${__date}" +%F_%T)".log
}

function update-git-repos {
	local repo_list_file
	local repo_list
	local git_dir
	local repo

	repo_list_file="${HOME}/.local/config/git-repos"

	if ! [ -f "${repo_list_file}" ]; then
		mkdir -p "$(dirname "${repo_list_file}")"
		touch "${repo_list_file}"
		echo "Created empty config file at ${repo_list_file}."
		echo "Add git repo paths to it, one path per line"
		return 1
	fi

	repo_list="$(< "${repo_list_file}")"
	if [ -z "${repo_list}" ]; then
		echo "Repo list is empty. Please update ${repo_list_file}"
		echo "${repo_list_file} should contain one git repo path per line"
		return 255
	fi

	# loop over repo list, and run `git remote update -p && git pull` on them.
	# "(f)" in "${(f)repo_list}" used to convert string into array, split
	# from newline characters
	for repo_path in "${(f)repo_list}"; do
		repo="$(basename "${repo_path}")"

		echo "Processing ${repo} @ ${repo_path}"

		git_dir="$(git -C "${repo_path}" rev-parse --git-dir 2>/dev/null)"
		if [ -z "${git_dir}" ]; then
			echo "Could not determine GIT_DIR for repo ${repo}. Skipping..."
			continue
		fi

		# GIT_DIR might be an absolute path, unrelated to "${repo_path}"
		if ! [ -d "${repo_path}/${git_dir}" ] && ! [ -d "${git_dir}" ]; then
			echo "It looks like ${repo} is not a git repository. Skipping..."
			continue
		fi
		echo "Fetching changes for ${repo}"
		if ! git -C "${repo_path}" remote update -p; then
			echo "git update failed for ${repo}"
			return 254
		fi
		echo "Update working tree for ${repo}"
		if ! git -C "${repo_path}" pull; then
			echo "git pull failed for ${repo}"
			return 253
		fi
	done
}

# shellcheck source=/dev/null disable=SC2154
[ -f "${ZSH_CONFIG_LOCAL_HOME}/funcs" ] && source "${ZSH_CONFIG_LOCAL_HOME}/funcs"
