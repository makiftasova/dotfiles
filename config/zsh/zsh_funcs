# find absolute path for given executable in PATH.
# omits shell builtins, shell functions and shell aliases while searching.
function find_exec_in_path {
	# $1 is executable name
	which -a "$1" | grep -e "^/" | head -1
}

# wrapper for ed(1) to change ed's prompt.
function ed {
	local __exec=$(find_exec_in_path "ed")
	local __prompt="$ED_PROMPT"
	if [ -z "$__exec" ] ; then
		echo "ed not found in PATH";
		return 1;
	fi
	if [ -z "$__prompt" ] ; then
		__prompt="ed> "
	fi
	eval "$__exec" "-p" "\"$__prompt\"" "$@"
}

function tex_to_pdf {
	pdflatex $1
}

# convert given markdown file into a pdf document
function md_to_pdf {
	pandoc --pdf-engine=pdflatex -V geometry:"top=2cm, bottom=1.5cm, left=2.cm, right=2cm" -o "$1.pdf" "$1"
}

function dmalloc {
	eval `command dmalloc -b $*`;
}

# make a new directory and cd into it
function mkcd {
	mkdir -p "$1" && cd "$1"
}

# create a new markdown note with name "$NAME_$DATE.md"
function mdnote {
	if [ "$#" != "1" ]; then
		return -1;
	fi
	$EDITOR "$1_$(date +%F).md"
}

# archive given directory in a tar archive
function ftar {
	tar cvf "$1.tar" "$1"
}

# archive given directory in a tar.gz archive
function ftargz {
	tar cvzf "$1.tar.gz" "$1"
}

# search recursively for files with given extension in given directory and
# add them into a tar.gz archive
function ftargz_ext {
	local PATTERN="$1"
	local DIR="$2"
	local OUTP

	if [ -z "$DIR" ]; then
		DIR="."
	fi

	OUTP="$(basename "$(readlink -f $DIR)").tar.gz"

	find "$DIR" -name "$PATTERN" -exec tar cvzf "$OUTP" {} +
}

function fid {
	local _dir
	local _name
	local _params
	local _cmd_ret=0

	if [ "$#" -eq "0" ]
	then
		_cmd_ret=0

	elif [ "$#" -le "2" ]
	then
		if [ "$#" -eq "1" ]
		then
			_dir="."
			_name="$1"
		else
			_dir="$1"
			_name="$2"
		fi
		find "$_dir" -name "$_name"
		_cmd_ret=$?

	else
		_dir="$1"
		_name="$2"
		_params="${@:3}"
		find "$_dir" "$_params" -name "$_name"
		_cmd_ret=$?
	fi

	return $_cmd_ret
}

function grep_libdep {
	local _pattern="$1"
	local _needle="$2"

	for f in $(fid . "$_pattern"); do
		echo "===== FILE: \"$f\" =====";
		readelf -a "$f" | grep "$_needle";
	done
	echo "==== DONE ====";
}

function grep_symbols {
	local _pattern="$1"
	local _needle="$2"

	for f in $(fid . "$_pattern"); do
		echo "===== FILE: \"$f\" =====";
		nm -alC "$f" | grep "$_needle";
	done
	echo "===== DONE =====";
}

function sizeof {
	local _dir=$(readlink -f "$1")
	local _root=$(pwd)

	cd "$_dir"
	# echo "$_dir"
	du -csh ./*
	cd "$_root"
}

# revert git repository into fresh state.
# * removes all out of tree files
# * reset git repo to HEAD
# * resets all submodules into their respective HEAD's
# * update all submodules
function repo_rinse {
	git clean -xfd
	git submodule foreach --recursive git clean -xfd
	git reset --hard
	git submodule foreach --recursive git reset --hard
	git submodule update --init --recursive
}

function git_gc_prune_all {
	for f in $(find $(pwd) -name ".git" -type d); do
		echo "processing: $f"
		git -C $(dirname $f) gc --aggressive --prune=all;
		echo "done: $f"
	done
}

function repo_prune {
	local _cwd=$(pwd)

	if [ "$#" -ne "0" ]
	then
		cd "$1"
	fi

	git remote prune origin

	if [ "$#" -ne "0" ]
	then
		cd "$_cwd"
	fi
}

function git_refs_gc {
	local __pwd="$(pwd)"
	local __refs_path="$(git config --global references.path)"
	for d in $(ls -l "$__refs_path" | grep '^d' | awk '{ print $9 }'); do
		cd "$__refs_path/$d";
		echo "git gc for repository $d";
		git gc;
	done
	cd "$__pwd" ;
}

# run given command until it fails the print it stdout and stderr outputs of
# its failure followed by number of runs it takes until command fails.
function run_until_fails {
	local CMD="$*"
	local COUNTER=0

	local SOUT
	local SERR

	SOUT=$(mktemp)
	SERR=$(mktemp)

	while "$CMD" >"$SOUT" 2>"$SERR"; do
		COUNTER=$((COUNTER + 1))
	done

	cat "$SOUT"
	cat "$SERR"

	echo "[INF] $CMD failed after $COUNTER attempts."

	rm -f "$SOUT" "$SERR"
}

function gif_to_mp4 {
	if [ -z $(command -v ffmpeg) ]; then
		echo "ffmpeg not found!";
		return -1;
	fi
	local inp="$1";
	local out="${inp%.*}.mp4"
	echo "$out"
	ffmpeg -i "$inp" -movflags faststart -pix_fmt yuv420p -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2" "$out"

}

[ -f "$ZSH_CONFIG_LOCAL_HOME/zsh_funcs" ] && source "$ZSH_CONFIG_LOCAL_HOME/zsh_funcs"
